# -*- coding: utf-8 -*-
"""
Created on Wed Sep 11 23:36:11 2024

@author: Hacer
"""

import argparse
import requests
from bs4 import BeautifulSoup
import urllib.parse
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import warnings
from urllib.parse import urlparse, urlunparse
import time
import logging

# Sertifika uyarılarını bastır
warnings.simplefilter('ignore', InsecureRequestWarning)

# Loglama yapılandırması
logging.basicConfig(filename='scanner.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def get_page_content(url, use_selenium=False, timeout=10):
    if use_selenium:
        # Selenium ile dinamik içeriği alıyorum
        options = Options()
        options.headless = True  # Tarayıcıyı arka planda çalıştır
        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
        driver.get(url)
        content = driver.page_source
        driver.quit()
        return content
    else:
        # Normal requests ile sayfa içeriğini alıyorum
        try:
            response = requests.get(url, verify=False, timeout=timeout)  # Sertifika doğrulamasını devre dışı bırak
            if response.status_code == 200:
                return response.text
            else:
                print(f"Sayfa Alınamadı. Statüs kod: {response.status_code}")
                return None
        except Exception as e:
            print(f"Bir hata oluştu: {e}")
            return None

def find_forms_and_links(url, use_selenium=False):
    content = get_page_content(url, use_selenium)
    if not content:
        return [], []

    soup = BeautifulSoup(content, 'html.parser')
    forms = soup.find_all('form')
    links = soup.find_all('a', href=True)

    print(f"Bulunan Formlar: {len(forms)}")
    print(f"Bulunan Linkler: {len(links)}")
    
    return forms, links

def sanitize_url(url):
    """
    URL'yi temizlemek ve standart bir formata dönüştürmek için kullanılır.
    """
    parsed_url = urlparse(url)
    scheme = parsed_url.scheme
    netloc = parsed_url.netloc
    path = parsed_url.path.rstrip('/')
    clean_url = urlunparse((scheme, netloc, path, '', '', ''))
    return clean_url

def is_within_scope(url, scope_domain):
    """
    URL'nin belirli bir domain içinde olup olmadığını kontrol eder.
    """
    parsed_url = urlparse(url)
    return parsed_url.netloc.endswith(scope_domain)

def request_with_retry(url, method='get', data=None, retries=3, timeout=10):
    """Belirli sayıda yeniden deneme ile istek yapar."""
    for _ in range(retries):
        try:
            if method == 'post':
                response = requests.post(url, data=data, verify=False, timeout=timeout)
            else:
                response = requests.get(url, verify=False, timeout=timeout)
            if response.status_code == 200:
                return response
        except Exception as e:
            print(f"Bir hata oluştu: {e}")
        time.sleep(2)  # Kısa bir bekleme süresi
    return None

def check_command_injection(url, forms, links, payloads, scope_domain):
    vulnerabilities_found = []
    sanitized_url = sanitize_url(url)

    for form in forms:
        action = form.get('action')
        method = form.get('method', 'get').lower()
        inputs = form.find_all('input')
        form_data = {}

        for input_element in inputs:
            name = input_element.get('name')
            if name:
                form_data[name] = "test"

        for payload in payloads:
            for key in form_data.keys():
                form_data[key] = payload

            full_url = urllib.parse.urljoin(sanitized_url, action)
            if method == 'post':
                if not is_within_scope(full_url, scope_domain):
                    continue
                response = request_with_retry(full_url, method='post', data=form_data)
            else:
                query_string = urllib.parse.urlencode(form_data)
                full_url = urllib.parse.urljoin(sanitized_url, action) + "?" + query_string
                if not is_within_scope(full_url, scope_domain):
                    continue
                response = request_with_retry(full_url, method='get')

            if response and any(term in response.text.lower() for term in ["error", "id", "ls", "whoami"]):
                log_msg = f"Olası Command Injection açığı formda bulundu: {full_url} - Payload: {payload}"
                logging.info(log_msg)
                vulnerabilities_found.append(log_msg)

    for link in links:
        href = link['href']
        full_url = urllib.parse.urljoin(sanitized_url, href)
        if not is_within_scope(full_url, scope_domain):
            continue

        for payload in payloads:
            test_url = full_url + urllib.parse.quote(payload)
            response = request_with_retry(test_url, method='get')

            if response and any(term in response.text.lower() for term in ["error", "id", "ls", "whoami"]):
                log_msg = f"Olası Command Injection açığı linkte bulundu: {test_url} - Payload: {payload}"
                logging.info(log_msg)
                vulnerabilities_found.append(log_msg)

    return vulnerabilities_found

def chunk_payloads(payloads, chunk_size):
    """Payload listesini parçalara böler."""
    for i in range(0, len(payloads), chunk_size):
        yield payloads[i:i + chunk_size]

def load_payloads(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            payloads = file.read().splitlines()
        return payloads
    except Exception as e:
        print(f"{file_path}: {e} dosyasından yükleme başarısız oldu.")
        return []

def main():
    parser = argparse.ArgumentParser(description='Command Injection Vulnerability Scanner')
    parser.add_argument('url', help='Hedef URL')
    parser.add_argument('scope_domain', help='Domain kısıtlaması için kullanılan domain')
    parser.add_argument('payloads_file', help='Command Injection payloads dosyası')
    parser.add_argument('--use_selenium', action='store_true', help='Selenium kullanarak dinamik içeriği işlemek için')
    parser.add_argument('--chunk_size', type=int, default=10, help='Her seferinde işlenecek payload sayısı')

    args = parser.parse_args()

    target_url = args.url
    scope_domain = args.scope_domain
    payloads_file = args.payloads_file
    use_selenium = args.use_selenium
    chunk_size = args.chunk_size

    command_payloads = load_payloads(payloads_file)
    forms, links = find_forms_and_links(target_url, use_selenium)

    if forms or links:
        for payload_chunk in chunk_payloads(command_payloads, chunk_size):
            vulnerabilities = check_command_injection(target_url, forms, links, payload_chunk, scope_domain)
            if vulnerabilities:
                for vulnerability in vulnerabilities:
                    print(vulnerability)
            else:
                print("Command Injection açığı bulunamadı.")
    else:
        print("Form veya link bulunamadı.")

if __name__ == "__main__":
    main()
